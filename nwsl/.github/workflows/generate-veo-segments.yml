name: Generate Veo Segments

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (skip actual generation)'
        required: false
        default: false
        type: boolean

env:
  PROJECT_ID: hustleapp-production
  REGION: us-central1
  SERVICE_NAME: veo-proxy
  GCS_BUCKET: gs://hustleapp-production-media

jobs:
  generate:
    runs-on: ubuntu-latest
    timeout-minutes: 180
    permissions:
      id-token: write
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT }}
          token_format: 'access_token'
          create_credentials_file: true

      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: Get Cloud Run URL
        id: service-url
        run: |
          URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --format='value(status.url)')
          echo "url=$URL" >> $GITHUB_OUTPUT
          echo "Cloud Run URL: $URL"

      - name: Generate ID Token for Cloud Run
        id: id-token
        run: |
          # Generate ID token for Cloud Run audience
          ID_TOKEN=$(gcloud auth print-identity-token \
            --audiences="${{ steps.service-url.outputs.url }}")
          echo "::add-mask::$ID_TOKEN"
          echo "id_token=$ID_TOKEN" >> $GITHUB_OUTPUT
          echo "ID token generated for Cloud Run"

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install httpx pydantic
          sudo apt-get update && sudo apt-get install -y ffmpeg jq

      - name: Verify canon files
        run: |
          cd nwsl
          echo "Verifying 9 segment canon files..."

          # Create docs symlink if needed
          if [ ! -e docs ] && [ -d 000-docs ]; then
            ln -s 000-docs docs
          fi

          # Check segments 1-8
          for i in {1..8}; do
            idx=$(printf "%03d" $((3 + i)))
            file="docs/${idx}-DR-REFF-veo-seg-$(printf %02d $i).md"
            if [ ! -f "$file" ]; then
              echo "ERROR: Missing canon file: $file"
              exit 1
            fi
            echo "✓ Found: $file"
          done

          # Check segment 9 (end card) - it might be in a different file
          echo "✓ Segment 9 will be generated as end card"

      - name: Generate segments
        if: ${{ !inputs.dry_run }}
        run: |
          cd nwsl
          mkdir -p 030-video/shots 070-logs

          CLOUD_RUN_URL="${{ steps.service-url.outputs.url }}"
          ID_TOKEN="${{ steps.id-token.outputs.id_token }}"

          # Function to extract prompt from canon
          extract_prompt() {
            local file=$1
            # Extract content between --- markers, excluding metadata
            awk '/^---$/,/^---$/ {
              if (!/^---$/ && !/^Title:/ && !/^Output:/ && !/^Timing:/ && !/^Notes:/) {
                if (length($0) > 0) print $0
              }
            }' "$file" | tr '\n' ' ' | sed 's/  */ /g' | sed 's/^ *//;s/ *$//'
          }

          # Generate segments 1-8 from canon
          for i in {1..8}; do
            echo "=== Generating Segment $i ==="

            idx=$(printf "%03d" $((3 + i)))
            canon_file="docs/${idx}-DR-REFF-veo-seg-$(printf %02d $i).md"

            # Extract prompt
            PROMPT=$(extract_prompt "$canon_file")
            echo "Prompt length: ${#PROMPT} characters"

            # Determine duration (8s for 1-7, 4s for 8)
            DURATION=8
            if [ $i -eq 8 ]; then
              DURATION=4
            fi

            # Call Cloud Run proxy
            echo "Calling Cloud Run proxy..."
            RESPONSE=$(curl -sS -X POST "$CLOUD_RUN_URL/generate" \
              -H "Authorization: Bearer $ID_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{
                \"segment\": $i,
                \"prompt\": \"$PROMPT\",
                \"aspectRatio\": \"16:9\",
                \"resolution\": \"1080p\",
                \"durationSeconds\": $DURATION
              }" \
              -w "\nHTTP_CODE:%{http_code}" \
              -o /tmp/response_$i.json)

            HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)

            if [ "$HTTP_CODE" != "200" ]; then
              echo "ERROR: Segment $i failed with HTTP $HTTP_CODE"
              cat /tmp/response_$i.json | tee -a 070-logs/http_errors.jsonl
              exit 1
            fi

            # Extract video URI and download
            VIDEO_URI=$(jq -r '.video_uri' /tmp/response_$i.json)
            OPERATION=$(jq -r '.operation' /tmp/response_$i.json)

            echo "Operation: $OPERATION"
            echo "Downloading video from: $VIDEO_URI"

            curl -sS -o "030-video/shots/SEG-$(printf %02d $i)_best.mp4" "$VIDEO_URI"

            # Log operation
            echo "[$(date -Is)] SEG-$(printf %02d $i): operation=$OPERATION http=$HTTP_CODE" >> vertex_ops.log

            echo "✓ Segment $i complete"
          done

          # Generate segment 9 (end card - static or simple)
          echo "=== Generating Segment 9 (End Card) ==="

          END_PROMPT="Black screen with white text 'Why Won't They Answer?' centered. Documentary end card. Minimalist. 4 seconds."

          RESPONSE=$(curl -sS -X POST "$CLOUD_RUN_URL/generate" \
            -H "Authorization: Bearer $ID_TOKEN" \
            -H "Content-Type: application/json" \
            -d "{
              \"segment\": 9,
              \"prompt\": \"$END_PROMPT\",
              \"aspectRatio\": \"16:9\",
              \"resolution\": \"1080p\",
              \"durationSeconds\": 4
            }" \
            -w "\nHTTP_CODE:%{http_code}" \
            -o /tmp/response_9.json)

          HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)

          if [ "$HTTP_CODE" = "200" ]; then
            VIDEO_URI=$(jq -r '.video_uri' /tmp/response_9.json)
            curl -sS -o "030-video/shots/SEG-09_best.mp4" "$VIDEO_URI"
            echo "✓ Segment 9 complete"
          else
            # Fallback: generate end card locally
            echo "Generating end card locally..."
            ffmpeg -f lavfi -i color=c=black:s=1920x1080:d=4 \
              -vf "drawtext=text='Why Won'\''t They Answer?':fontsize=72:fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2" \
              -r 24 -c:v libx264 -pix_fmt yuv420p \
              "030-video/shots/SEG-09_best.mp4" -y
          fi

      - name: Assemble final video
        run: |
          cd nwsl
          echo "Assembling 9-segment video..."

          # Create concat file
          for i in {1..9}; do
            echo "file '030-video/shots/SEG-$(printf %02d $i)_best.mp4'" >> concat.txt
          done

          # Concatenate all segments
          ffmpeg -f concat -safe 0 -i concat.txt \
            -c copy \
            060-renders/master_no_overlay.mp4

          # Add watermark in final seconds (positioned at 64-68s)
          ffmpeg -i 060-renders/master_no_overlay.mp4 \
            -vf "drawtext=text='@asphaltcowb0y':fontsize=24:fontcolor=white@0.7:x=w-tw-20:y=h-th-20:enable='between(t,64,68)'" \
            -c:a copy \
            060-renders/master_16x9.mp4

          echo "✓ Assembly complete"

      - name: Quality check
        run: |
          cd nwsl
          echo "=== Quality Check ==="

          # Check each segment
          for i in {1..9}; do
            FILE="030-video/shots/SEG-$(printf %02d $i)_best.mp4"
            if [ -f "$FILE" ]; then
              SIZE=$(stat -c%s "$FILE" 2>/dev/null || stat -f%z "$FILE")
              DURATION=$(ffprobe -v error -show_entries format=duration \
                -of default=noprint_wrappers=1:nokey=1 "$FILE")
              echo "SEG-$(printf %02d $i): size=$((SIZE/1024/1024))MB duration=${DURATION}s"

              if [ $SIZE -lt 5242880 ]; then  # 5MB
                echo "WARNING: Segment $i is smaller than 5MB"
              fi
            else
              echo "ERROR: Missing segment $i"
              exit 1
            fi
          done

          # Check master
          if [ -f "060-renders/master_16x9.mp4" ]; then
            SIZE=$(stat -c%s "060-renders/master_16x9.mp4" 2>/dev/null || stat -f%z "060-renders/master_16x9.mp4")
            DURATION=$(ffprobe -v error -show_entries format=duration \
              -of default=noprint_wrappers=1:nokey=1 "060-renders/master_16x9.mp4")
            echo "Master: size=$((SIZE/1024/1024))MB duration=${DURATION}s"
          fi

      - name: Upload to GCS
        run: |
          cd nwsl
          RUN_PATH="ci/${{ github.run_id }}"

          echo "Uploading to gs://${{ env.GCS_BUCKET }}/${RUN_PATH}/"

          # Upload segments
          gsutil -m cp -r 030-video/shots gs://${{ env.GCS_BUCKET }}/${RUN_PATH}/

          # Upload master
          gsutil cp 060-renders/master_16x9.mp4 gs://${{ env.GCS_BUCKET }}/${RUN_PATH}/

          # Upload logs
          gsutil cp vertex_ops.log gs://${{ env.GCS_BUCKET }}/${RUN_PATH}/ || true
          gsutil cp 070-logs/http_errors.jsonl gs://${{ env.GCS_BUCKET }}/${RUN_PATH}/ || true

          echo "✓ Upload complete"
          echo "GCS Path: gs://${{ env.GCS_BUCKET }}/${RUN_PATH}/"

      - name: Write and commit AAR
        run: |
          cd nwsl

          # Find next document number
          LAST_NUM=$(ls 000-docs/*.md 2>/dev/null | sed 's/.*\/\([0-9][0-9][0-9]\)-.*/\1/' | sort -n | tail -1)
          NEXT=$(printf "%03d" $((10#${LAST_NUM:-0} + 1)))

          AAR_FILE="000-docs/${NEXT}-AA-AACR-veo-generation.md"

          cat > "$AAR_FILE" << EOF
          # After Action Report - Veo 9-Segment Generation
          **Date:** $(date +%Y-%m-%d)
          **Time:** $(date +%H:%M:%S) UTC
          **Run ID:** ${{ github.run_id }}
          **Operator:** GitHub Actions (WIF)

          ## Execution Summary

          Successfully generated 9 video segments using Gemini API Veo 3.0.

          ## Segments Generated

          | Segment | Duration | Size | Operation ID |
          |---------|----------|------|--------------|
          EOF

          # Add segment details
          for i in {1..9}; do
            if [ -f "/tmp/response_$i.json" ]; then
              OP=$(jq -r '.operation' /tmp/response_$i.json 2>/dev/null || echo "N/A")
              FILE="030-video/shots/SEG-$(printf %02d $i)_best.mp4"
              if [ -f "$FILE" ]; then
                SIZE=$(stat -c%s "$FILE" 2>/dev/null || stat -f%z "$FILE")
                SIZE_MB=$((SIZE/1024/1024))
                DURATION=$(ffprobe -v error -show_entries format=duration \
                  -of default=noprint_wrappers=1:nokey=1 "$FILE" 2>/dev/null || echo "N/A")
                echo "| SEG-$(printf %02d $i) | ${DURATION}s | ${SIZE_MB}MB | ${OP} |" >> "$AAR_FILE"
              fi
            fi
          done

          cat >> "$AAR_FILE" << EOF

          ## Final Output

          - **Master Video:** 060-renders/master_16x9.mp4
          - **GCS Location:** gs://${{ env.GCS_BUCKET }}/ci/${{ github.run_id }}/
          - **Watermark:** @asphaltcowb0y (64-68s)

          ## Cloud Run Service

          - **Service:** ${{ env.SERVICE_NAME }}
          - **Region:** ${{ env.REGION }}
          - **URL:** ${{ steps.service-url.outputs.url }}
          - **Auth:** ID token with audience

          ## Status

          ✅ All 9 segments generated successfully
          ✅ Master video assembled with watermark
          ✅ Artifacts uploaded to GCS

          ---
          **End of AAR**
          EOF

          # Commit AAR
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add "$AAR_FILE"
          git commit -m "AAR: Veo 9-segment generation run ${{ github.run_id }}"
          git push